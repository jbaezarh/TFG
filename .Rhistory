recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
dt_workflow <-
workflow() %>%
add_model(dt_mod) %>%
add_recipe(dt_recipe)
dt_res <-
dt_workflow %>%
fit(train)
dt_res <-
dt_workflow %>%
fit(training)
plot(dt_res)
plot(dt_res |> extract_fit_engine())
dt_res |> extract_fit_engine()
dt = dt_res |> extract_fit_engine()
dt
dt$csplit
dt$cptable
dt_mod <-
decision_tree(cost_complexity = tune()) %>%
set_engine("rpart") %>%
set_mode("classification")
dt_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
dt_workflow <-
workflow() %>%
add_model(dt_mod) %>%
add_recipe(dt_recipe)
?decision_tree
dt_mod <-
decision_tree(cost_complexity = tune()) %>%
set_engine("rpart") %>%
set_mode("classification")
dt_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
dt_workflow <-
workflow() %>%
add_model(dt_mod) %>%
add_recipe(dt_recipe)
# 4º Train and tune
set.seed(345)
dt_res <-
dt_workflow %>%
#fit(training)
tune_grid(val_set,
grid = 5,
control = control_grid(save_pred = TRUE),
metrics = metric_set(accuracy,roc_auc,recall,spec))
plot(dt_res |> extract_fit_engine())
dt_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
autoplot(dt_res)
plot(dt_res)
autoplot(dt_res)
dt_res <-
dt_workflow %>%
#fit(training)
tune_grid(val_set,
grid = 10,
control = control_grid(save_pred = TRUE),
metrics = metric_set(accuracy,roc_auc,recall,spec))
dt_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
autoplot(dt_res)
dt_best <- dt_res |>
select_best(metric = "recall")
dt_best
dt_best |> collect_predictions() |> get_metrics()
dt_best |> get_metrics()
dt_res |> collect_predictions(parameters = dt_best) |> get_metrics()
dt_best <- dt_res |>
select_best(metric = "accuracy")
dt_res |> collect_predictions(parameters = dt_best) |> get_metrics()
dt_best <- dt_res |>
select_best(metric = "specificity")
dt_best <- dt_res |>
select_best(metric = "specificity")
dt_best <- dt_res |>
select_best(metric = "spec")
dt_res |> collect_predictions(parameters = dt_best) |> get_metrics()
dt_best <- dt_res |>
select_best(metric = "accuracy")
dt_res |> collect_predictions(parameters = dt_best) |> get_metrics()
# Detectar el número de núcleos para trabajar en paralelo
cores <- parallel::detectCores()
cores
# 1º Construir el modelo
rf_mod <-
rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>%
set_engine("ranger", num.threads = cores) %>%
set_mode("classification")
# 2º Construir la receta con el preprocesamiento
rf_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
# 3º Ensamblar todo con workflow
rf_workflow <-
workflow() %>%
add_model(rf_mod) %>%
add_recipe(rf_recipe)
# 4º Train and tune
rf_mod
extract_parameter_set_dials(rf_mod)
set.seed(345)
load("salidas_intermedias/trained_models/trained_models_strat_24_04_27.RData")
rf_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
# Mejor modelo
rf_best <-
rf_res %>%
select_best(metric = "accuracy")
rf_best
scale_x_log10(labels = scales::label_number())
dt_plot <-
dt_res %>%
collect_metrics() %>%
# filter(.metric == "accuracy") %>%
ggplot(aes(x = cost_complexity, y = mean,col=.metric)) +
geom_point() +
geom_line() +
ylab("Medidas de rendimiento") +
scale_x_log10(labels = scales::label_number())
dt_plot
dt_res |> extract_fit_engine()
dt_workflow %>%
finalize_workflow(dt_best) %>%
fit(training) %>%
extract_fit_engine() %>%
tidy()
dt_workflow %>%
finalize_workflow(dt_best) %>%
fit(training) %>%
extract_fit_engine()
dt_workflow %>%
finalize_workflow(dt_best) %>%
fit(training) %>%
extract_fit_engine() |> plot()
args(decision_tree)
dt_mod <-
decision_tree(cost_complexity = 0.001,tree_depth = 50, min_n = 1) %>%
set_engine("rpart") %>%
set_mode("classification")
dt_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
dt_workflow <-
workflow() %>%
add_model(dt_mod) %>%
add_recipe(dt_recipe)
# 4º Train and tune
set.seed(345)
dt_res <-
dt_workflow %>%
fit(training)
dt_mod <-
decision_tree(cost_complexity = 0.001,tree_depth = 30, min_n = 1) %>%
set_engine("rpart") %>%
set_mode("classification")
dt_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
dt_workflow <-
workflow() %>%
add_model(dt_mod) %>%
add_recipe(dt_recipe)
# 4º Train and tune
set.seed(345)
dt_res <-
dt_workflow %>%
fit(training)
dt_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
autoplot(dt_res)
dt_res |> collect_predictions() |> get_metrics()
dt_res |> extract_fit_engine() |> plot()
lrs_pred = cbind(predict(dt_res,new_data = validation(splits),type="class"),
fire = validation(splits)$fire)
lrs_pred |> get_metrics()
lrs_pred
lrs_pred = cbind(predict(dt_res,new_data = validation(splits),type="class"),
predict(dt_res,new_data = validation(splits),type="prob")
fire = validation(splits)$fire)
lrs_pred = cbind(predict(dt_res,new_data = validation(splits),type="class"),
predict(dt_res,new_data = validation(splits),type="prob"),
fire = validation(splits)$fire)
lrs_pred |> get_metrics()
dt_mod <-
nearest_neighbor(neighbors = tune()) %>%
set_engine("kknn") %>%
set_mode("classification")
knn_mod <-
nearest_neighbor(neighbors = tune()) %>%
set_engine("kknn") %>%
set_mode("classification")
knn_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow","month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>% # Se eliminan variables identificadoras
step_dummy(all_nominal_predictors()) %>% # Se crean variables dummy para los factores
step_lincomb(all_predictors()) %>%
step_corr(all_date_predictors()) %>%
step_zv(all_predictors()) %>% # Eliminar variables con varianza nula
step_normalize(all_predictors()) # Se normalizan todos los predictores
knn_workflow <-
workflow() %>%
add_model(knn_mod) %>%
add_recipe(knn_recipe)
# 4º Train and tune
set.seed(345)
# 4º Train and tune
set.seed(345)
knn_res <-
dt_workflow %>%
# fit(training)
tune_grid(val_set,
grid = 20,
control = control_grid(save_pred = TRUE),
metrics = metric_set(accuracy,roc_auc,recall,spec))
knn_mod <-
nearest_neighbor(neighbors = tune()) %>%
set_engine("kknn") %>%
set_mode("classification")
knn_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow","month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>% # Se eliminan variables identificadoras
step_dummy(all_nominal_predictors()) %>% # Se crean variables dummy para los factores
step_lincomb(all_predictors()) %>%
step_corr(all_date_predictors()) %>%
step_zv(all_predictors()) %>% # Eliminar variables con varianza nula
step_normalize(all_predictors()) # Se normalizan todos los predictores
knn_mod <-
nearest_neighbor(neighbors = tune()) %>%
set_engine("kknn") %>%
set_mode("classification")
knn_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow","month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>% # Se eliminan variables identificadoras
step_dummy(all_nominal_predictors()) %>% # Se crean variables dummy para los factores
step_lincomb(all_predictors()) %>%
step_corr(all_date_predictors()) %>%
step_zv(all_predictors()) %>% # Eliminar variables con varianza nula
step_normalize(all_predictors()) # Se normalizan todos los predictores
knn_workflow <-
workflow() %>%
add_model(knn_mod) %>%
add_recipe(knn_recipe)
# 4º Train and tune
set.seed(345)
knn_res <-
knn_workflow %>%
# fit(training)
tune_grid(val_set,
grid = 20,
control = control_grid(save_pred = TRUE),
metrics = metric_set(accuracy,roc_auc,recall,spec))
install.packages("kknn")
install.packages("kknn")
install.packages("kknn")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "D:/usuario/Documents/Universidad/5º/TFG - organizado") # Para que haga knitr desde el directorio del proyecto
# Chunk 2
library(tidyverse)
library(tidymodels)
library(sf)
library(ggplot2)
library(akima) # interp
library(magrittr)
library(ggpubr)
# Chunk 3
load("salidas_intermedias/datos_strat_depurados_geom_2024-04-27.RData")
# load("salidas_intermedias/datos_depurados_geom_2024-04-23.RData")
# load("salidas_intermedias/datos_depurados_geom_2024-04-26.RData")
library(forcats)
datos <- datos |>
mutate(uso_suelo = fct_lump(uso_suelo,
n = 7, # nos quedamos con los 7 niveles del factor más frecuentes (clases 2 y 3)
other_level= "Otro"))
table(datos$uso_suelo,datos$fire)
# Chunk 4
# Función para obtener las medidas de rendimiento de los modelos a partir de un objeto predict
get_metrics <- function(pred) {
list(
res = tibble(
roc_auc = pred |> roc_auc(truth = fire, .pred_0) |> pull(.estimate),
accuracy = pred |> accuracy(truth = fire, .pred_class) |> pull(.estimate),
recall = pred |> sensitivity(truth = fire, .pred_class,event_level="second") |> pull(.estimate),
specificity = pred |> spec(truth = fire, .pred_class,event_level="second") |> pull(.estimate)),
conf_mat = pred |> conf_mat(truth = fire, .pred_class))
}
# Función para mostrar graficamente los resultados del tuning de un modelo con dos parámetros
tuning_plot = function(mod_res) {
datos_metrics = mod_res %>%
collect_metrics()
# min = min(datos_metrics$mean)
# max = max(datos_metrics$mean)
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos[[1]], datos[[2]], datos$mean)
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = colnames(datos)[1],
y = colnames(datos)[2],
fill = metric)
plots[[metric]] = p
}
# ggarrange(plotlist = plots,
#           legend = "right",
#           common.legend = T)
ggarrange(plotlist = plots)
}
# Chunk 5
set.seed(123)
splits = initial_validation_time_split(datos,
prop=c(0.6,0.2))
training <- training(splits) %>%  st_drop_geometry()
val_set <- validation_set(splits) %>% st_drop_geometry()
test  <- testing(splits) %>% st_drop_geometry()
# # Para hacerlo por fecha manualmente:
# splits <- make_splits(
#   x = list(analysis = which(year(datos$date)<2021),
#            assessment = which(year(datos$date)>=2021)),
#   data=datos
# )
#
# training_val <- training(splits)
# test  <- testing(splits)
#
#
# length(splits$out_id)/length(splits$in_id)
# [1] 0.1149578
#
# 1.a. Partición train- validation
# set.seed(234)
# val <- make_splits(
#   x = list(analysis = which(year(datos$date)<2018),
#            assessment = which(year(datos$date)>=2018)),
#   data=datos
# )
#
# val_set <- validation_time_split(training_val,
#                                  prop = 0.80)
# Chunk 6
# 1º Definimos el modelo:
lr_mod <-
logistic_reg(penalty = tune(), mixture = tune()) %>%
set_engine("glmnet")
# 2º Creamos la receta
lr_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow","month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>% # Se eliminan variables identificadoras
step_dummy(all_nominal_predictors()) %>% # Se crean variables dummy para los factores
step_zv(all_predictors()) %>% # Eliminar variables con varianza nula
step_normalize(all_predictors()) # Se normalizan todos los predictores
# 3º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 4º Creamos el grid para los parámetros
lr_reg_grid <- expand_grid(penalty = 10^seq(-4, -1, length.out = 30),
mixture = c(0,1))
# 5º Ajustamos el modelo
lr_res <-
lr_workflow %>%
tune_grid(val_set,
grid = lr_reg_grid,
control = control_grid(save_pred = TRUE),
metrics = metric_set(accuracy,roc_auc,recall,spec))
# 6º Evaluación de modelos
# Se muestran las medidas de rendimiento en función del parámetro de penalización
lr_plot <-
lr_res %>%
collect_metrics() %>%
# filter(.metric == "accuracy") %>%
ggplot(aes(x = penalty, y = mean,col=.metric,linetype=as.factor(mixture))) +
geom_point() +
geom_line() +
ylab("Medidas de rendimiento") +
scale_x_log10(labels = scales::label_number())
lr_plot
lr_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
lr_res %>%
show_best(metric = "accuracy", n = 15)
lr_res %>% tuning_plot()
# 7º Selección del mejor modelo
lr_best <-
lr_res %>%
select_best(metric="accuracy")
lr_best
# 8º Se evalúa el modelo:
# Curva ROC
lr_auc <-
lr_res %>%
collect_predictions(parameters = lr_best) %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Logistic Regression")
autoplot(lr_auc)
#   Medidas de rendimiento
lr_metrics <- lr_res |>
collect_predictions(parameters = lr_best) |>
get_metrics()
lr_metrics
# Chunk 7
## No tengo claro como medir los residuos en un modelo de clasificación:
lr_residuals = lr_res %>%
collect_predictions(parameters = lr_best) %>%
mutate(residual = fire !=.pred_class,
geometry = st_geometry(validation(splits))) %>%
st_as_sf(sf_column_name ="geometry")
ggplot(lr_residuals,aes(col=residual)) +
geom_sf(alpha=0.6) +
labs(col = "Error")
dt_mod <-
decision_tree(cost_complexity = tune()) %>%
set_engine("rpart") %>%
set_mode("classification")
dt_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date) %>%
step_rm(date, cod_municipio, municipio)
dt_workflow <-
workflow() %>%
add_model(dt_mod) %>%
add_recipe(dt_recipe)
# 4º Train and tune
set.seed(345)
dt_res <-
dt_workflow %>%
# fit(training)
tune_grid(val_set,
grid = 10,
control = control_grid(save_pred = TRUE),
metrics = metric_set(accuracy,roc_auc,recall,spec))
dt_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
lr_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
dt_plot <-
dt_res %>%
collect_metrics() %>%
# filter(.metric == "accuracy") %>%
ggplot(aes(x = cost_complexity, y = mean,col=.metric)) +
geom_point() +
geom_line() +
ylab("Medidas de rendimiento") +
scale_x_log10(labels = scales::label_number())
dt_plot
dt_best <- dt_res |>
select_best(metric = "accuracy")
dt_res |> collect_predictions(parameters = dt_best) |> get_metrics()
dt_workflow %>%
finalize_workflow(dt_best) %>%
fit(training) %>%
extract_fit_engine() |> plot()
dt_workflow %>%
finalize_workflow(dt_best) %>%
fit(training) %>%
extract_fit_engine()
lrs_pred = cbind(predict(dt_res,new_data = validation(splits),type="class"),
predict(dt_res,new_data = validation(splits),type="prob"),
fire = validation(splits)$fire)
dt_best <- dt_res |>
select_best(metric = "accuracy")
