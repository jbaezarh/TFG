# min = min(datos_metrics$mean)
# max = max(datos_metrics$mean)
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos$mtry, datos$min_n, datos$mean)
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = "mtry",
y = "min_n",
fill = metric)
plots[[metric]] = p
}
# ggarrange(plotlist = plots,
#           legend = "right",
#           common.legend = T)
ggarrange(plotlist = plots)
}
tuning_plot(svm_res)
mod_res = svm_res
mod_res
datos_metrics = mod_res %>%
collect_metrics()
datos_metrics
tunning_plot(rf_res)
datos
datos = datos_metrics %>%
filter(.metric==metric) %>%
select(which(is.numeric))
datos = datos_metrics %>%
filter(.metric==metric) %>%
select(is.numeric)
datos = datos_metrics %>%
filter(.metric==metric) %>%
select(where(is.numeric))
datos
# Interpolar los datos faltantes
datos_interp <- interp(datos[1,], datos[2,], datos[3,])
datos = datos_metrics %>%
filter(.metric==metric)
datos
tuning_plot = function(mod_res) {
datos_metrics = mod_res %>%
collect_metrics()
# min = min(datos_metrics$mean)
# max = max(datos_metrics$mean)
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos$mtry, datos$min_n, datos$mean)
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = "mtry",
y = "min_n",
fill = metric)
plots[[metric]] = p
}
# ggarrange(plotlist = plots,
#           legend = "right",
#           common.legend = T)
ggarrange(plotlist = plots)
}
tuning_plot(rf_res)
class(datos$mtry)
datos
str(datos$mtry)
str(datos[,1])
str(datos[[,1]])
str(datos[[1]])
datos
colnames(datos)[1]
################
tuning_plot = function(mod_res) {
datos_metrics = mod_res %>%
collect_metrics()
# min = min(datos_metrics$mean)
# max = max(datos_metrics$mean)
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos[[1]], datos[[2]], datos[[3]])
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = colnames(datos)[1],
y = colnames(datos)[2],
fill = metric)
plots[[metric]] = p
}
# ggarrange(plotlist = plots,
#           legend = "right",
#           common.legend = T)
ggarrange(plotlist = plots)
}
tuning_plot(rf_res)
tuning_plot(svm_res)
datos_metrics = mod_res %>%
collect_metrics()
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos[[1]], datos[[2]], datos[[3]])
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = colnames(datos)[1],
y = colnames(datos)[2],
fill = metric)
plots[[metric]] = p
}
datos = datos_metrics %>%
filter(.metric==metric)
datos
# Interpolar los datos faltantes
datos_interp <- interp(datos[[1]], datos[[2]], datos[[3]])
datos
datos[[1]]
datos[[2]]
datos[[3]]
################
tuning_plot = function(mod_res) {
datos_metrics = mod_res %>%
collect_metrics()
# min = min(datos_metrics$mean)
# max = max(datos_metrics$mean)
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos[[1]], datos[[2]], datos$mean)
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = colnames(datos)[1],
y = colnames(datos)[2],
fill = metric)
plots[[metric]] = p
}
# ggarrange(plotlist = plots,
#           legend = "right",
#           common.legend = T)
ggarrange(plotlist = plots)
}
tuning_plot(rf_res)ç
tuning_plot(rf_res)
tuning_plot(svm_res)
tuning_plot = function(mod_res) {
datos_metrics = mod_res %>%
collect_metrics()
# min = min(datos_metrics$mean)
# max = max(datos_metrics$mean)
plots = list()
for (metric in unique(datos_metrics$.metric)) {
datos = datos_metrics %>%
filter(.metric==metric)
# Interpolar los datos faltantes
datos_interp <- interp(datos[[1]], datos[[2]], datos$mean)
# Crear un nuevo dataframe con los datos interpolados
datos_interp_df <- data.frame(
expand.grid(x = datos_interp$x, y = datos_interp$y), z = as.vector(datos_interp$z))
# Crear el gráfico de mapa de calor con interpolación
p = ggplot(datos_interp_df, aes(x = x, y = y, fill = z)) +
geom_tile() +
# scale_fill_viridis_c(option = "turbo", limits = c(min,max), name = NULL)+
scale_fill_viridis_c(option = "turbo", name = NULL)+
labs(title = metric,
x = colnames(datos)[1],
y = colnames(datos)[2],
fill = metric)
plots[[metric]] = p
}
# ggarrange(plotlist = plots,
#           legend = "right",
#           common.legend = T)
ggarrange(plotlist = plots)
}
tuning_plot(rf_res)
# Resultados del tuning
svm_res |>
collect_metrics() |>
group_by(.metric)|>
summarise(max = max(mean),min=min(mean))
tuning_plot(svm_res)
# Mejor modelo
svm_best <-
svm_res %>%
select_best(metric="accuracy")
svm_best
# Curva ROC
svm_auc <-
sv_res %>%
collect_predictions(parameters = svm_best) %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Support Vector Machine")
# Curva ROC
svm_auc <-
svm_res %>%
collect_predictions(parameters = svm_best) %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Support Vector Machine")
autoplot(svm_auc)
get_metrics(lr_res)
lr_res %>% collect_predictions() %>% get_metrics()
lr_res %>% collect_predictions() %>% get_metrics()$res
lr_res %>% collect_predictions() %>% get_metrics() %>% .$res
lr_res %>% collect_predictions() %>% roc_auc(truth = fire, .pred_0) |> pull(.estimate)
lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
pull(res)
lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
.$res
results = tribble(
lr = lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
.$res,
rf = rf_res %>%
collect_predictions(parameters = rf_best) %>%
get_metrics() %>%
.$res,
svm = svm_res %>%
collect_predictions(parameters = svm_best) %>%
get_metrics() %>%
.$res
)
lr = lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
.$res,
lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
.$res
results = rbind(
lr = lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
.$res,
rf = rf_res %>%
collect_predictions(parameters = rf_best) %>%
get_metrics() %>%
.$res,
svm = svm_res %>%
collect_predictions(parameters = svm_best) %>%
get_metrics() %>%
.$res
)
results
rownames(results) = c("lr","rf","svm")
results = rbind(
lr = lr_res %>%
collect_predictions(parameters = lr_best) %>%
get_metrics() %>%
.$res %>%
as.data.frame(),
rf = rf_res %>%
collect_predictions(parameters = rf_best) %>%
get_metrics() %>%
.$res %>%
as.data.frame(),
svm = svm_res %>%
collect_predictions(parameters = svm_best) %>%
get_metrics() %>%
.$res %>%
as.data.frame()
)
results
kable(results,digits=2)
kable(results,digits=2)
library(knitr)
kable(results,digits=2)
kable(results,digits=3)
# Comparación
bind_rows(rf_auc, lr_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1.5, alpha = 0.8) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "plasma", end = .6)
# Comparación
bind_rows(rf_auc, lr_auc,svm_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1.5, alpha = 0.8) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "plasma", end = .6)
# Comparación
bind_rows(rf_auc, lr_auc,svm_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1, alpha = 0.7) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "plasma", end = .6)
# Comparación
bind_rows(rf_auc, lr_auc,svm_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1, alpha = 0.7) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "turbo", end = .6)
# Comparación
bind_rows(rf_auc, lr_auc,svm_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1, alpha = 0.7) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "turbo")
, end = .6
# Comparación
bind_rows(rf_auc, lr_auc,svm_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1, alpha = 0.7) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "turbo", end = .6)
# the last model
last_lr_mod <- logistic_reg(parameters = lr_best) |>
set_engine("glmnet")
# the last model
lr_best
# the last model
lr_best
last_lr_mod <- logistic_reg(penalty = lr_best$penalty, mixture = 0) |>
set_engine("glmnet")
# the last workflow
last_lr_workflow <-
lr_workflow %>%
update_model(last_lr_mod)
# the last fit
set.seed(345)
splits
last_lr_fit <-
last_lr_workflow %>%
last_fit(splits)
last_lr_fit
last_lr_fit %>%
collect_metrics()
last_lr_fit
last_lr_fit %>%
collect_metrics()
last_lr_fit
splits
last_lr_fit %>%
collect_metrics()
last_lr_fit <-
last_lr_workflow %>%
last_fit(splits,
add_validation_set = T)
last_lr_fit
last_lr_fit %>%
collect_metrics()
last_lr_fit %>%
collect_predictions()
last_lr_fit %>%
collect_predictions() %>%
get_metrics()
# Test
# the last model
last_rf_mod <-
rand_forest(mtry = 3, min_n = 3, trees = 1000) %>%
set_engine("ranger", num.threads = cores) %>%
set_mode("classification")
# Test
# the last model
rf_best
last_rf_mod <-
rand_forest(mtry = rf_best$mtry, min_n = rf_best$min_n, trees = 1000) %>%
set_engine("ranger", num.threads = cores) %>%
set_mode("classification")
?rand_forest
rf_best
# Test
# the last model
rf_best
last_rf_mod <-
rand_forest(mtry = rf_best$mtry, min_n = rf_best$min_n, trees = 1000) %>%
set_engine("ranger", num.threads = cores) %>%
set_mode("classification")
# the last workflow
last_rf_workflow <-
rf_workflow %>%
update_model(last_rf_mod)
set.seed(345)
last_rf_fit <-
last_rf_workflow %>%
last_fit(splits,
add_validation_set = T)
last_rf_fit
last_rf_fit %>%
collect_metrics()
res_rf = last_rf_fit %>%
collect_predictions() %>%
get_metrics()
rm(res_rf)
last_rf_fit %>%
collect_predictions() %>%
get_metrics()
library(vip)
last_rf_fit %>%
extract_fit_parsnip() %>%
vip(num_features = 20)
last_rf_mod <-
rand_forest(mtry = rf_best$mtry, min_n = rf_best$min_n, trees = 1000) %>%
set_engine("ranger", num.threads = cores,importance="impurity") %>%
set_mode("classification")
# the last workflow
last_rf_workflow <-
rf_workflow %>%
update_model(last_rf_mod)
set.seed(345)
last_rf_fit <-
last_rf_workflow %>%
last_fit(splits,
add_validation_set = T)
last_rf_fit %>%
collect_metrics()
last_rf_fit %>%
collect_predictions() %>%
get_metrics()
library(vip)
last_rf_fit %>%
extract_fit_parsnip() %>%
vip(num_features = 20)
last_rf_fit %>%
collect_predictions() %>%
roc_curve(fire, .pred_0) %>%
autoplot()
rf_coef = last_rf_fit %>%
extract_fit_engine() |>
tidy()
# the last model
svm_best
last_svm_mod <-
rand_forest(cost = svm_best$cost, margin = svm_best$margin) %>%
set_engine("kernlab") %>%
set_mode("classification")
last_svm_mod <-
svm_linear(cost = svm_best$cost, margin = svm_best$margin) %>%
set_engine("kernlab") %>%
set_mode("classification")
# the last workflow
last_svm_workflow <-
svm_workflow %>%
update_model(last_svm_mod)
# the last fit
set.seed(345)
last_svm_fit <-
last_svm_workflow %>%
last_fit(splits,
add_validation_set = T)
last_svm_fit
last_svm_fit %>%
collect_metrics()
last_sv_fit %>%
collect_predictions() %>%
get_metrics()
last_svm_fit %>%
collect_predictions() %>%
get_metrics()
last_lr_fit %>%
collect_predictions() %>%
get_metrics()
last_rf_fit %>%
collect_predictions() %>%
get_metrics()
last_svm_fit %>%
collect_predictions() %>%
get_metrics()
