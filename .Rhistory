year <- 2007
incendios <- st_read(paste0("./data_raw/incendios_2000-2022/incendios_",year,".shp"))
incendios
read_sf("D:/usuario/Documents/Universidad/5º/TFG - organizado/Private/incendios_2007/incendios_2007.shp")
View(incendios)
incendios <- st_read(paste0("./data_raw/incendios_2000-2022/incendios_",year,".shp"))
incendios
View(incendios)
year <- 2008
incendios <- st_read(paste0("./data_raw/incendios_2000-2022/incendios_",year,".shp"))
View(incendios)
is.Date(ymd(2018))
ymd(2018)
?ymd
for (year in 2002:2022) {
incendios <- st_read(paste0("./data_raw/incendios_2000-2022/incendios_",year,".shp"))
total = total + nrow(incendios)
}
total = 0
for (year in 2002:2022) {
incendios <- st_read(paste0("./data_raw/incendios_2000-2022/incendios_",year,".shp"))
total = total + nrow(incendios)
}
total
1129-1090
rast("D:/usuario/Documents/Universidad/5º/TFG - organizado/data_raw/vegetacion/2020TERMODMEDMNDVI/InfGeografica/InfRaster/TIFF/termod_200101_h17v05_medmndvi.tif")
ndvi <- rast("D:/usuario/Documents/Universidad/5º/TFG - organizado/data_raw/vegetacion/2020TERMODMEDMNDVI/InfGeografica/InfRaster/TIFF/termod_200101_h17v05_medmndvi.tif")
ndvi
as.numeric(ndvi)
max(ndvi)
min(ndvi)
summary(ndvi)
knitr::opts_chunk$set(echo = TRUE)
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
library(tidyverse)
library(tidymodels)
library(tidymodels)
library(sf)
library(ggplot2)
library(terra)
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
pred = cbind(predict(lr_res,new_data = validation(splits),type="prob"),
predict(lr_res,new_data = validation(splits),type="class"),
fire = validation(splits)$fire)
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
load("salidas_intermedias/datos_depurados_geom_2024-04-23.RData")
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
set.seed(123)
splits = initial_validation_time_split(datos,
prop=c(0.6,0.2))
training <- training(splits) %>%  st_drop_geometry()
val_set <- validation_set(splits) %>% st_drop_geometry()
test  <- testing(splits) %>% st_drop_geometry()
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
# 4º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
pred = cbind(predict(lr_res,new_data = validation(splits),type="prob"),
predict(lr_res,new_data = validation(splits),type="class"),
fire = validation(splits)$fire)
pred
# 6º Se evalúa el modelo:
#   Curva ROC
lr_auc <- pred %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Logistic Regression")
autoplot(lr_auc)
#   Medidas de rendimiento
lr_metrics <- pred |>
get_metrics()
#   Medidas de rendimiento
get_metrics <- function(pred) {
list(
res = tibble(
roc_auc = pred |> roc_auc(truth = fire, .pred_0) |> pull(.estimate),
accuracy = pred |> accuracy(truth = fire, .pred_class) |> pull(.estimate),
recall = pred |> sensitivity(truth = fire, .pred_class) |> pull(.estimate),
specificity = pred |> spec(truth = fire, .pred_class) |> pull(.estimate)),
conf_mat = pred |> conf_mat(truth = fire, .pred_class))
}
lr_metrics <- pred |>
get_metrics()
lr_metrics
terra::predict()
?terra::predict
datos = datos %>% select(fire,elevacion,curvatura,orientacion,pendiente)
splits = initial_validation_time_split(datos,
prop=c(0.6,0.2))
training <- training(splits) %>%  st_drop_geometry()
val_set <- validation_set(splits) %>% st_drop_geometry()
test  <- testing(splits) %>% st_drop_geometry()
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
# 4º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
lr_recipe <-
recipe(fire ~ ., data = training) %>%
#  step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
# 4º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
lr_recipe <-
recipe(fire ~ ., data = training) %>%
#  step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
#  step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
# 4º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
pred = cbind(predict(lr_res,new_data = validation(splits),type="prob"),
predict(lr_res,new_data = validation(splits),type="class"),
fire = validation(splits)$fire)
pred
# 6º Se evalúa el modelo:
#   Curva ROC
lr_auc <- pred %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Logistic Regression")
autoplot(lr_auc)
#   Medidas de rendimiento
get_metrics <- function(pred) {
list(
res = tibble(
roc_auc = pred |> roc_auc(truth = fire, .pred_0) |> pull(.estimate),
accuracy = pred |> accuracy(truth = fire, .pred_class) |> pull(.estimate),
recall = pred |> sensitivity(truth = fire, .pred_class) |> pull(.estimate),
specificity = pred |> spec(truth = fire, .pred_class) |> pull(.estimate)),
conf_mat = pred |> conf_mat(truth = fire, .pred_class))
}
lr_metrics <- pred |>
get_metrics()
lr_metrics
elev <- rast("data_raw/topograficas/elevacion.tif")
pend <- rast("data_raw/topograficas/pendiente.tif")
orient <- rast("data_raw/topograficas/orientacion.tif")
curv <- rast("data_raw/topograficas/curvatura.tif")
elevacion <- rast("data_raw/topograficas/elevacion.tif")
pendiente <- rast("data_raw/topograficas/pendiente.tif")
orientacion <- rast("data_raw/topograficas/orientacion.tif")
curvatura <- rast("data_raw/topograficas/curvatura.tif")
orientacion = cut(orientacion,
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
?terra::classify
m = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,
-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360,
"Plano","N","NE","E","SE","S","SW","W","NW","N")
library(raster)
?raster::cut
orientacion = raster::cut(orientacion,
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
orientacion = raster::cut(orientacion,
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360))
orientacion = raster::cut(orientacion,
breaks = c(-100,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360))
library(raster)
r <- raster(ncols=36, nrows=18)
values(r) <- rnorm(ncell(r))
class(orientacion)
orientacion
orientacion = raster::cut(as.numeric(orientacion),
breaks = c(-100,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360))
library(raster)
r <- raster(ncols=36, nrows=18)
values(r) <- rnorm(ncell(r))
breaks <- -2:2 * 3
rc <- cut(r, breaks=breaks)
rc
orientation[]
orientacion[]
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
elevacion <- rast("data_raw/topograficas/elevacion.tif")
pendiente <- rast("data_raw/topograficas/pendiente.tif")
orientacion <- rast("data_raw/topograficas/orientacion.tif")
curvatura <- rast("data_raw/topograficas/curvatura.tif")
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
orientacion
newdata = c(elevacion,pendiente,orientacion,curvatura)
elevacion <- rast("data_raw/topograficas/elevacion.tif") %>% as.numeric()
pendiente <- rast("data_raw/topograficas/pendiente.tif") %>% as.numeric()
orientacion <- rast("data_raw/topograficas/orientacion.tif") %>% as.numeric()
curvatura <- rast("data_raw/topograficas/curvatura.tif") %>% as.numeric()
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
newdata = c(elevacion,pendiente,orientacion,curvatura)
# Resamplear para que coincidan los los ráster pixel a pixel, se usa de modelo, elevacion
pendiente = resample(pendiente, elevacion)
orientacion = resample(orientacion, elevacion)
curvatura = resample(curvatura, elevacion)
newdata = c(elevacion,pendiente,orientacion,curvatura)
# Resamplear para que coincidan los los ráster pixel a pixel, se usa de modelo, elevacion
pendiente = resample(pendiente, elevacion)
crs(pendiente)
crs(elevacion)
?resample
# Resamplear para que coincidan los los ráster pixel a pixel, se usa de modelo, elevacion
pendiente = terra::
# Resamplear para que coincidan los los ráster pixel a pixel, se usa de modelo, elevacion
pendiente = terra::resample(pendiente, elevacion)
crs(elevacion)==crs(pendiente)
?project
pendiente = terra::project(pendiente, elevacion,align=T)
c(elevacion,pendiente)
pendiente = terra::project(pendiente, elevacion,align=T)
orientacion = project(orientacion, elevacion,align=T)
curvatura = project(curvatura, elevacion,align=T)
elevacion <- rast("data_raw/topograficas/elevacion.tif") %>% as.numeric()
pendiente <- rast("data_raw/topograficas/pendiente.tif") %>% as.numeric() %>% project()
# Codificar orientacion
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
elevacion <- rast("data_raw/topograficas/elevacion.tif") %>% as.numeric()
pendiente <- rast("data_raw/topograficas/pendiente.tif") %>% as.numeric()
orientacion <- rast("data_raw/topograficas/orientacion.tif") %>% as.numeric()
curvatura <- rast("data_raw/topograficas/curvatura.tif") %>% as.numeric()
# Codificar orientacion
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
pendiente = terra::project(pendiente, elevacion,align=T)
orientacion = project(orientacion, elevacion,align=T)
curvatura = project(curvatura, elevacion,align=T)
newdata = c(elevacion,pendiente,orientacion,curvatura)
c(pendiente,elevacion)
pendiente = terra::project(pendiente, elevacion,align=T)
c(pendiente,elevacion)
pendiente = project(pendiente, elevacion,align=T) %>% resample(pendiente,elevacion)
?terra::resample
pendiente = project(pendiente, elevacion,align=T) %>% resample(pendiente,elevacion)
pendiente = project(pendiente, elevacion) %>%
resample(elevacion)
elevacion <- rast("data_raw/topograficas/elevacion.tif") %>% as.numeric()
pendiente <- rast("data_raw/topograficas/pendiente.tif") %>% as.numeric()
orientacion <- rast("data_raw/topograficas/orientacion.tif") %>% as.numeric()
curvatura <- rast("data_raw/topograficas/curvatura.tif") %>% as.numeric()
# Codificar orientacion
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
pendiente = project(pendiente, elevacion) %>% resample(elevacion)
orientacion = project(orientacion, elevacion) %>% resample(elevacion)
curvatura = project(curvatura, elevacion) %>% resample(elevacion)
newdata = c(elevacion,pendiente,orientacion,curvatura)
terra::predict(lr_res,newdata)
terra::predict()
terra::predict
?terra::predict
terra::predict(object = newdata,model = lr_res)
newdata
names(newdata)
names(newdata)  = c("elevacion","pendiente","orientacion","curvatura")
terra::predict(object = newdata,model = lr_res)
newdata = c(elevacion,pendiente,curvatura)
names(newdata)  = c("elevacion","pendiente","curvatura")
terra::predict(object = newdata,model = lr_res)
datos = datos %>% select(fire,elevacion,curvatura,pendiente)
splits = initial_validation_time_split(datos,
prop=c(0.6,0.2))
training <- training(splits) %>%  st_drop_geometry()
val_set <- validation_set(splits) %>% st_drop_geometry()
test  <- testing(splits) %>% st_drop_geometry()
```
```{r}
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
#  step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
#  step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
# 4º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
pred = cbind(predict(lr_res,new_data = validation(splits),type="prob"),
predict(lr_res,new_data = validation(splits),type="class"),
fire = validation(splits)$fire)
pred
# 6º Se evalúa el modelo:
#   Curva ROC
lr_auc <- pred %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Logistic Regression")
autoplot(lr_auc)
#   Medidas de rendimiento
get_metrics <- function(pred) {
list(
res = tibble(
roc_auc = pred |> roc_auc(truth = fire, .pred_0) |> pull(.estimate),
accuracy = pred |> accuracy(truth = fire, .pred_class) |> pull(.estimate),
recall = pred |> sensitivity(truth = fire, .pred_class) |> pull(.estimate),
specificity = pred |> spec(truth = fire, .pred_class) |> pull(.estimate)),
conf_mat = pred |> conf_mat(truth = fire, .pred_class))
}
lr_metrics <- pred |>
get_metrics()
lr_metrics
lr_metrics
```{r}
elevacion <- rast("data_raw/topograficas/elevacion.tif") %>% as.numeric()
pendiente <- rast("data_raw/topograficas/pendiente.tif") %>% as.numeric()
orientacion <- rast("data_raw/topograficas/orientacion.tif") %>% as.numeric()
curvatura <- rast("data_raw/topograficas/curvatura.tif") %>% as.numeric()
# Codificar orientacion
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
pendiente = project(pendiente, elevacion) %>% resample(elevacion)
orientacion = project(orientacion, elevacion) %>% resample(elevacion)
curvatura = project(curvatura, elevacion) %>% resample(elevacion)
newdata = c(elevacion,pendiente,curvatura)
names(newdata)  = c("elevacion","pendiente","curvatura")
terra::predict(object = newdata,model = lr_res)
datos
datos = datos %>% select(fire,elevacion,curvatura,pendiente)
library(sf)
datos = datos %>% select(fire,elevacion,curvatura,pendiente)
datos = datos %>% st_drop_geometry() %>%  select(fire,elevacion,curvatura,pendiente)
datos = datos %>% st_drop_geometry() %>%  dplyr::select(fire,elevacion,curvatura,pendiente)
set.seed(123)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2
library(tidyverse)
library(tidymodels)
library(sf)
library(ggplot2)
library(terra)
# Chunk 3
load("salidas_intermedias/datos_depurados_geom_2024-04-23.RData")
# Chunk 4
set.seed(123)
datos = datos %>% st_drop_geometry() %>%  dplyr::select(fire,elevacion,curvatura,pendiente)
splits = initial_validation_time_split(datos,
prop=c(0.6,0.2))
training <- training(splits) %>%  st_drop_geometry()
val_set <- validation_set(splits) %>% st_drop_geometry()
test  <- testing(splits) %>% st_drop_geometry()
# Chunk 5
#2º definimos el modelo
lr_mod <-
logistic_reg(penalty = NULL, mixture = NULL) %>%
set_engine("glm")
# 3º Creamos la receta
# holidays <- c("AllSouls", "AshWednesday", "ChristmasEve", "Easter",
#               "ChristmasDay", "GoodFriday", "NewYearsDay", "PalmSunday")
lr_recipe <-
recipe(fire ~ ., data = training) %>%
#  step_date(date,features = c("dow", "month")) %>%
# step_holiday(date, holidays = holidays) %>%
#  step_rm(date,cod_municipio,municipio) %>%
step_dummy(all_nominal_predictors()) %>%
step_zv(all_predictors()) %>%
step_normalize(all_predictors())
# 4º Creamos el workflow
lr_workflow <-
workflow() %>%
add_model(lr_mod) %>%
add_recipe(lr_recipe)
# 5º Ajustamos el modelo.
lr_res <-
lr_workflow %>%
fit(training)
pred = cbind(predict(lr_res,new_data = validation(splits),type="prob"),
predict(lr_res,new_data = validation(splits),type="class"),
fire = validation(splits)$fire)
pred
# 6º Se evalúa el modelo:
#   Curva ROC
lr_auc <- pred %>%
roc_curve(fire, .pred_0) %>%
mutate(model = "Logistic Regression")
autoplot(lr_auc)
#   Medidas de rendimiento
get_metrics <- function(pred) {
list(
res = tibble(
roc_auc = pred |> roc_auc(truth = fire, .pred_0) |> pull(.estimate),
accuracy = pred |> accuracy(truth = fire, .pred_class) |> pull(.estimate),
recall = pred |> sensitivity(truth = fire, .pred_class) |> pull(.estimate),
specificity = pred |> spec(truth = fire, .pred_class) |> pull(.estimate)),
conf_mat = pred |> conf_mat(truth = fire, .pred_class))
}
lr_metrics <- pred |>
get_metrics()
lr_metrics
elevacion <- rast("data_raw/topograficas/elevacion.tif") %>% as.numeric()
pendiente <- rast("data_raw/topograficas/pendiente.tif") %>% as.numeric()
orientacion <- rast("data_raw/topograficas/orientacion.tif") %>% as.numeric()
curvatura <- rast("data_raw/topograficas/curvatura.tif") %>% as.numeric()
# Codificar orientacion
orientacion[] = cut(orientacion[],
breaks = c(-Inf,-1,22.5,67.5,112.5,157.5,202.5,247.5,292.5,337.5,360),
labels = c("Plano","N","NE","E","SE","S","SW","W","NW","N"))
pendiente = project(pendiente, elevacion) %>% resample(elevacion)
orientacion = project(orientacion, elevacion) %>% resample(elevacion)
curvatura = project(curvatura, elevacion) %>% resample(elevacion)
newdata = c(elevacion,pendiente,curvatura)
names(newdata)  = c("elevacion","pendiente","curvatura")
terra::predict(object = newdata,model = lr_res)
terra::predict(object = newdata,model = lr_res)
